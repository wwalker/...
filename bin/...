#!/usr/bin/env perl
# use XXX;use YAML;use YAML::Loader;
# Next line removes site dirs, so we don't pull in non-core modules.
BEGIN { @INC = grep not(/\bsite/), @INC }

# TODO:
# - backup needs to save the .../conf file

my $usage = <<'...';

        ... - The Unix Dot File Manager

Usage: ... [options] command [command-options]

Commands:
    conf conf-file-path | conf-file-url | <stdin>
	      - Put content into the .../conf configuration file.
    backup    - Backup all the dot files that would be changed by 'install'.
    install   - Copy or link all the dot files into your $HOME directory.
      -h | --hardlink Use hardlinks (default)
      -s | --symlink  Use symlinks
      -f | --copy     Full copy
    list      - List all the full paths of the files that would be installed.
    status    - Get change status of all the dot repositories.
    conflicts - Show dot files that collide with ones from other repos.
    update    - Fetch changes from all the dot repositories.
    upgrade   - Do update and then install.
    restore   - Restore a backup.
    remove    - DELETE all the dot files in $HOME that would be installed!!!
    env       - Get input for a shell eval `... env`, useful for scripting.
    super_update         - parallel update
    sup                  - alias for super_update
    super_update_install - parallel update + install
    supi                 - alias for super_update_install
    help      - Print this help and exit.

Options:
    -v --version    Print the version and exit.
    -h -?           Same as 'help' command.

For complete documentation, run: 'perldoc ...'

...

use strict;

# Load inlined modules. Can't read DATA in BEGIN block so do it manually.
BEGIN {
    eval do {
        open I, $0 or die;
        local $/; $_ = <I>; s/^.*\n__DATA__\n//s or die; $_;
    } or die;
}

# Load modules:
use YAML::Tiny;
use File::Path;
use Getopt::Long;
use Cwd;
use File::Spec;

my $VERSION = '1.0.0';

#-------------------------------------------------------------------------------
# State variables
#-------------------------------------------------------------------------------

# $HOME env
my $home_dir = $ENV{HOME} or die "Error: \$HOME not set\n";
my $command;        # backup, install, etc
my $handler;        # Class method to call
# ~/.../
my $root_dir = "$home_dir/...";
my $root_entry = { path => $root_dir };
# ~/.../conf
my $conf_file = "$root_dir/conf";
my $config;         # Config hash
my $timestamp;      # Time stamp
my $restore_from;   # Directory to restore from
my $conf_path;

my $cli_install_method = '';

my $no_conf_msg = <<"...";
Error: '$conf_file' does not exist.

Run `... conf <path-or-url>` to set it up.

You can also copy $root_dir/example.conf to $conf_file
and edit appropriately.

...

#-------------------------------------------------------------------------------
# Processing starts here
#-------------------------------------------------------------------------------
TOP: {
    my $class = __PACKAGE__;
    $class->parse_command_line();
    $class->setup() unless $command =~ /^(help|version|conf)$/;
    $class->$handler();
}

sub parse_command_line {
    my $class = shift;
    if (@ARGV == 0) {
        $command = 'default';
    }
    elsif ($ARGV[0] =~ /^(-\?|-h|--help)$/) {
        $command = 'help';
    }
    elsif ($ARGV[0] =~ /^(-v|--version)$/) {
        $command = 'version'
    }
    elsif ($ARGV[0] eq 'ls') {
        $command = 'list'
    }
    elsif ($ARGV[0] eq 'st') {
        $command = 'status'
    }
    elsif ($ARGV[0] eq 'rm') {
        $command = 'remove'
    }
    elsif ($ARGV[0] eq 'restore') {
        $command = 'restore';
        $restore_from = splice @ARGV, 1, 1
            or die "Error: 'restore' command requires a backup directory argument";
    }
    elsif ($ARGV[0] eq 'conf') {
        $command = 'conf';
        $conf_path = splice(@ARGV, 1, 1) || '';
    }
    elsif ($ARGV[0] =~ /^-/) {
        die "Error: '$ARGV[0]' is an invalid option\n";
    }
    else {
        $command = $ARGV[0];
    }
    if ($command eq 'install') {
        if ($ARGV[1] =~ /^(-h|--hardlink)$/) {
            $cli_install_method = 'hardlink';
            splice(@ARGV, 1, 1);
        }
        if ($ARGV[1] =~ /^(-s|--symlink)$/) {
            $cli_install_method = 'symlink';
            splice(@ARGV, 1, 1);
        }
        if ($ARGV[1] =~ /^(-f|--copy)$/) {
            $cli_install_method = 'copy';
            splice(@ARGV, 1, 1);
        }
    }
    if (@ARGV > 1) {
        die "Error: invalid usage. Try: '.../... -h'.\n";
    }
    $handler = "do_$command";
    die "Error: unsupported command '$command'\n"
        unless $class->can($handler);
}

sub setup {
    my $class = shift;

    -d $root_dir or die "Error: $root_dir is not a directory\n";
    -f $conf_file or die $no_conf_msg;
    $config = YAML::Tiny::LoadFile($conf_file);

    $config->{dot_paths_base} ||= 'src';

    my $dots = $config->{dots} || $config->{dot_paths}
        or die "Error: 'dots' not defined in $conf_file\n";
    die "Error: 'dots' needs to be a sequence of mappings.\n"
        if ref($dots) ne 'ARRAY' or
        not(@$dots) or
        grep {ref ne 'HASH'} @$dots;
    die "Error: each dot_path entry must have a 'path' or 'repo' value\n"
        if grep {
            not defined $_->{path} and
            not defined $_->{repo}
        } @$dots;
    delete $config->{dot_paths};
    $config->{dots} = $dots;

    $config->{auto_backup} =
        not(exists($config->{auto_backup})) ? 1 :
        $config->{auto_backup} =~ /^(on|true|1)$/ ? 1 :
        $config->{auto_backup} =~ /^(off|false|0)$/ ? 0 :
        die "Error: invalid value for conf setting 'auto_backup'\n";

    $config->{install_method} ||= 'hardlink';
    die "Error: invalid value for conf setting 'install_method'\n"
        unless $config->{install_method} =~ /^(hardlink|symlink|copy)$/;

    my ($sec, $min, $hour, $day, $mon, $year) = localtime(time);
    $year += 1900;
    $mon++;
    $timestamp = sprintf "%04d%02d%02d-%02d%02d%02d", $year, $mon, $day, $hour, $min, $sec;
}

#-------------------------------------------------------------------------------
# The do_ subcommand handlers are defined here in 'usage' order:
#-------------------------------------------------------------------------------
sub do_default {
    my $class = shift;
    $class->do_help;
}

sub do_conf {
    my $class = shift;
    die "'$conf_file' already exists\n"
        if -f $conf_file;
    if (not $conf_path) {
        my $text = do {local $/; <STDIN>};
        open OUT, ">$conf_file" or die "Can't open $conf_file for output";
        print OUT $text;
        close $text;
    }
    elsif ($conf_path =~ m!^https?://!) {
        $class->_run_sys("curl $conf_path > $conf_file");
    }
    elsif ($conf_path =~ /:/) {
        $class->_run_sys("scp $conf_path $conf_file");
    }
    elsif (-f $conf_path) {
        $class->_run_sys("cp $conf_path $conf_file");
    }
    else {
        die "Unknown argument '$conf_path' for '... conf'\n";
    }
}

sub do_backup {
    my $class = shift;
    my $quiet = shift or 0;
    my $backup_dir = "$root_dir/backup/$timestamp";
    my $backup_list_file = "$root_dir/tmp/$timestamp-backup-list";
    print color(32, "Backing up your dot files to $backup_dir/\n");
    open F, "> $backup_list_file";
    my $n = 0;
    for my $file (sort keys %{$class->_all_files}) {
        next unless -e "$home_dir/$file";
        $n++;
        print "$file\n" unless $quiet;
        print F "$file\n";
    }
    close F;
    my $cmd = "(cd $home_dir; mkdir -p $backup_dir && cat $backup_list_file | cpio -dump $backup_dir)";
    $class->_run_sys($cmd);
    print color(32, "Backed up $n dot files to $backup_dir\n");
}

sub do_install {
    my $class = shift;
    $class->do_backup('quiet') if $config->{auto_backup};
    print color(34, "Installing your dot files:\n");
    $class->_each_make('install');
    my $all_files = $class->_all_files;
    my $method = $cli_install_method || $config->{install_method};
    my $n = 0;
    my $n_skipped = 0;
    for my $file (sort keys %$all_files) {
        my $src = "$all_files->{$file}/$file";
        my $dst = "$home_dir/$file";
        if ($class->_up_to_date($src, $dst, $method)) {
            $n_skipped++;
            next;
        }
        $n++;
        my $dir = $dst;
        $dir =~ s/(.*\/).*/$1/;
        if (not -d $dir) {
            File::Path::mkpath($dir) >= 1 or die "Can't make path '$dir'";
        }
        unlink $dst;
        if ('copy' eq $method) {
            $class->_run_sys("cp $src $dst");
        } elsif ('hardlink' eq $method) {
            cmd_print(35, "ln $src $dst");
            link $src, $dst or fatal_error("Could not hardlink $src to $dst");
        } elsif ('symlink' eq $method) {
            cmd_print("36;1", "ln -s $src $dst");
            symlink $src, $dst or fatal_error("Could not symlink $src to $dst");
        } else {
            die "Invalid install method '$method'";
        }
    }
    $class->_check_deps;
    print _install_report_for($n, $n_skipped, $method);
    if ('symlink' eq $method) {
        my @watched_dirs = map { "$home_dir/$_" } qw(tg-bin bin .sh .zsh .bash .vim);
        my @existing_watched_dirs = grep { -d } @watched_dirs;
        print "  Checking for dead symlinks in @existing_watched_dirs\n";
        my @bad_symlinks = $class->_find_dead_symlinks(@existing_watched_dirs);
        for my $bad (@bad_symlinks) {
            print "    Removing: ", color("31;1", $bad), "\n";
            unlink $bad or warn "Weird. Couldn't unlink('$bad').";
        }
        if (0 == @bad_symlinks) {
            print "    (None found.)\n";
        }
    }
}

sub do_super_update_install {
    my $class = shift;
    $class->do_super_update;
    $class->do_install;
}

sub do_supi { (shift)->do_super_update_install(@_) }
sub do_super_upgrade { (shift)->do_super_update_install(@_) }

sub _install_report_for {
    my ($n, $n_skipped, $method) = @_;
    my $total = color(34, $n + $n_skipped) . ' installed files.';
    my @parenthetical = ();
    push @parenthetical, color(33, $n_skipped) . ' skipped' if $n_skipped;
    my $verbed = ucfirst $method . 'ed';
    $verbed =~ s/yed$/ied/;
    push @parenthetical, color(32, $n) . " $verbed" if $n;
    my $parenthetical = join " | ", @parenthetical;
    "$total ($parenthetical)\n";
}

sub do_list {
    my $class = shift;
    my $all_files = $class->_all_files;
    for my $file (sort keys %$all_files) {
        my $path = $all_files->{$file};
        print "$path/$file\n";
    }
}

sub do_status {
    my $class = shift;
    for my $entry ($root_entry, $class->_all_dot_paths) {
        my $path = $entry->{path};
        next unless -d "$path/.git";
        my $cmd = "(cd $path; git status)";
        $class->_run_sys($cmd);
    }
}

sub do_conflicts {
    my $class = shift;
    my $all_files = $class->_all_files(1);
    for my $file (sort keys %$all_files) {
        my $list = $all_files->{$file};
        next unless ref($list) eq 'ARRAY';
        print '= ' . shift(@$list) . "/$file\n";
        print "  x $_/$file\n" for @$list;
    }
}

sub do_update {
    my $class = shift;
    print "Updating your `...` system and dot files:\n";
    for my $entry ($root_entry, $class->_all_dot_paths) {
        $class->_update_one($entry);
    }
}

sub do_super_update {
    my $class = shift;
    print "Updating your `...` system and dot files... " .
        color('32;1', 'in parallel') . "!\n";
    my @kids = ();
    for my $entry ($root_entry, $class->_all_dot_paths) {
        my $kidpid = fork;
        if (!$kidpid) {
            $class->_update_one($entry);
            exit;
        } else {
            push @kids, $kidpid;
        }
    }
    waitpid $_, 0 for @kids;
}

sub do_sup { (shift)->do_super_update(@_) }

sub _update_one {
    my $class = shift;
    my $entry = shift;
    my $path = $entry->{path};
    my $repo = $entry->{repo} || '';
    my $branch = $entry->{branch} ? " --branch $entry->{branch}" : '';
    if (! -d $path) {
        if ($repo) {
            $class->_run_sys("git clone$branch --depth 1 --recursive $repo $path");
            $class->_make(update => $path);
        }
        else {
            die "$path does not exist and there is not 'repo' entry";
        }
    }
    else {
        if (! -d "$path/.git") {
            warn "$path exists, but is not a git repo. Ignoring.";
        }
        else {
            my $pull = 'git pull --ff-only';
            my $submods = 'git submodule update --init';
            $class->_run_sys("(cd $path && $pull && $submods)");
            $class->_make(update => $path);
        }
    }
}

sub do_upgrade {
    my $class = shift;
    $class->do_update;
    $class->do_install;
}

sub do_restore {
    my $class = shift;
    die "'$restore_from' is not a backup directory"
        unless -d $restore_from;

    $class->do_backup('quiet') if $config->{auto_backup};
    print "Restoring your dot files from $restore_from\n";
    my $cmd = "(cd $restore_from; find . | cpio -dump $home_dir)";
    $class->_run_sys($cmd);
    print "Restore complete.\n";
}

sub do_remove {
    my $class = shift;
    $class->do_backup('quiet') if $config->{auto_backup};
    print "Removing all your installed dot files:\n";
    my $all_files = $class->_all_files;
    my $n = 0;
    chdir $home_dir;
    for my $file (sort keys %$all_files) {
        if (-e $file) {
            my $cmd = "rm -f $file";
            $class->_run_sys($cmd);
            $n++;
        }
        if ((my $dir = $file) =~ s!(.*)/.*!$1!) {
            rmdir $dir;
        }
    }
    print "Deleted $n dot files\n";
}

sub do_env {
    my $class = shift;
    print <<EOT
: See http://github.com/sharpsaw/loop-dots for ideas on how to use these;
export DOTDOTDOT_ROOT='$root_dir';
export DOTDOTDOT_ORDER='${\ join ' ', map $_->{path}, $class->_all_dot_paths}';
EOT
}

sub do_help {
    my $class = shift;
    print $usage;
}

sub do_version {
    my $class = shift;
    print "This is '...' version '$VERSION'\n\n";
}

# This is inside this file because of the odd tricks with the fat-packed libs
# giving me a slight bit of trouble with loading this file from another file
# in t/. I didn't look too close, though. —☈king
sub do_unittest {
    my $class = shift;
    chdir or die $!;
    chdir '.../t' or die $!;
    $class->_quiet_run_sys('rm -rf tmp');
    $class->_quiet_run_sys('mkdir tmp');
    $class->_quiet_run_sys('cp ../... tmp/an-example');
    $class->_quiet_run_sys('cp echo-foo tmp/another-example');
    chdir 'tmp' or die $!;
    $class->_quiet_run_sys('cp an-example a-copy');
    $class->_quiet_run_sys('cp an-example modified-copy');
    $class->_quiet_run_sys('echo foo >> modified-copy');
    $class->_quiet_run_sys('ln an-example a-hardlink');
    $class->_quiet_run_sys('ln -s an-example a-symlink');
    $class->_quiet_run_sys('ln -s a-symlink double-symlink');
    $class->_quiet_run_sys('ln -s another-example another-symlink');
    $class->_quiet_run_sys('ln -s non-existent a-bad-symlink');
    $class->_quiet_run_sys('mkdir dir');
    $class->_quiet_run_sys('ln -s non-existent dir/another-bad-symlink');

    for my $case (
        [ qw(0 copy     an-example no-exist) ],
        [ qw(0 hardlink an-example no-exist) ],
        [ qw(0 symlink  an-example no-exist) ],

        [ qw(0 copy     an-example modified-copy) ],
        [ qw(0 hardlink an-example modified-copy) ],
        [ qw(0 symlink  an-example modified-copy) ],

        [ qw(0 copy     an-example a-bad-symlink) ],
        [ qw(0 hardlink an-example a-bad-symlink) ],
        [ qw(0 symlink  an-example a-bad-symlink) ],

        [ qw(1 copy     an-example a-copy) ],
        [ qw(0 hardlink an-example a-copy) ],
        [ qw(0 symlink  an-example a-copy) ],

        [ qw(0 copy     an-example a-hardlink) ],
        [ qw(1 hardlink an-example a-hardlink) ],
        [ qw(0 symlink  an-example a-hardlink) ],

        [ qw(0 copy     an-example an-example) ],
        [ qw(1 hardlink an-example an-example) ],
        [ qw(0 symlink  an-example an-example) ],

        [ qw(0 copy     an-example a-symlink) ],
        [ qw(0 hardlink an-example a-symlink) ],
        [ qw(1 symlink  an-example a-symlink) ],

        [ qw(0 copy     an-example a-bad-symlink) ],
        [ qw(0 hardlink an-example a-bad-symlink) ],
        [ qw(0 symlink  an-example a-bad-symlink) ],

        [ qw(0 copy     a-symlink another-symlink) ],
        [ qw(0 hardlink a-symlink another-symlink) ],
        [ qw(0 symlink  a-symlink another-symlink) ],
    ) {
        my ($expected, $method, $x, $y) = @$case;
        my $actual = $class->_up_to_date($x, $y, $method);
        warn "Expected $expected, got $actual, "
            . "for $method comparison for $x vs. $y to be $expected\n"
            unless ($expected and $actual) or (!$expected and !$actual);
    }
    my @reapworthy = $class->_find_dead_symlinks('.');
    2 == scalar @reapworthy
      and './a-bad-symlink' eq $reapworthy[0]
      and './dir/another-bad-symlink' eq $reapworthy[1]
        or die "_find_dead_symlinks failed (@reapworthy)";
    $class->_quiet_run_sys('cd ..; rm -r tmp');

    for my $case (
        [ {path => 'explicit-path' } => 'explicit-path' ],
        [ {repo => 'git@github.com/foo/ssh-url.git' } => 'ssh-url' ],
        [ {repo => 'https://github.com/foo/https-url' } => 'https-url' ],
        [ {repo => 'https://github.com/foo/slash-url/' } => 'slash-url' ],
    ) {
        my ($input, $expected) = @$case;
        my $actual = $class->_deduce_path($input);
        warn "Expected $expected, got $actual\n"
            unless $expected eq $actual;
    }
}

#-------------------------------------------------------------------------------
# Helper methods
#-------------------------------------------------------------------------------
sub fatal_error {
    my $msg = shift;
    die "$msg\n" unless -t STDERR;
    warn "...", color(31, $msg), "\n";
    print STDERR "  Hit Enter to try to continue anyway, or Ctrl+c to stop:";
    <STDIN>;
}

sub color {
    my ($color, $text) = @_;
    "\e[${color}m$text\e[0m"
}

sub cmd_print {
    my ($color, @cmd) = @_;
    my @cleaned = map { s/$ENV{HOME}/~/g; $_ } @cmd;
    print '> ', color($color, "@cleaned\n");
}

# Run a system command (and print it too)
sub _run_sys {
    my ($class, @cmd) = @_;
    local $" = ' ';
    cmd_print(36, @cmd);
    $class->_quiet_run_sys(@cmd);
}
sub _quiet_run_sys {
    my ($class, @cmd) = @_;
    system(@cmd) == 0 or fatal_error "Failed to: @cmd";
}

sub _find_dead_symlinks {
    my ($class, @dirs) = @_;
    my @reaped = ();
    for my $dir (@dirs) {
        opendir my $dh, $dir or fatal_error("Couldn't open $dir");
        while (readdir $dh) {
            my $path = "$dir/$_";
            if (-l $path) {
                push @reaped, $path if not -e $path;
            } elsif (-d $path and $path !~ /\/\.\.?$/) {
                push @reaped, $class->_find_dead_symlinks($path);
            }
        }
    }
    @reaped
}

# Check is a file needs to be updated or not. Deals with files, links and
# symlinks.
sub _up_to_date {
    my $class = shift;
    my $src = shift;
    my $dst = shift;
    my $method = shift;
    die "Error: '$src' file does not exist" unless -f $src;
    return 0 if -s $dst != -s $src;
    if ('symlink' eq $method) {
        return readlink($dst) eq $src
    }
    return $class->_up_to_date($src, $dst, 'symlink') if -l $src;
    return 0 if -l $src ne -l $dst;
    if ('copy' eq $method) {
        return 0 if _inode_of($src) == _inode_of($dst);
        open S, $src or die;
        open D, $dst or die;
        local $/;
        return <S> eq <D>
    } elsif ('hardlink' eq $method) {
        return _inode_of($src) == _inode_of($dst)
    } else {
        die "Invalid method $method."
    }
}

sub _inode_of {
    my $file_name = shift;
    my ($dev, $ino) = stat $file_name;
    return $ino
}

# Check if a file needs to be updated or not
sub _all_dot_paths {
    my $class = shift;
    my @paths;
    for my $entry (@{$config->{dots}}) {
        my $result = {};
        my $path = $class->_deduce_path($entry) || fatal_error "No path found";
        if ($path !~ /^\//) {
            $path = "$config->{dot_paths_base}/$path";
        }
        if ($path !~ /^\//) {
            $path = "$root_dir/$path";
        }
        die "Error: can't resolve path for '" . $entry->{path} . "'\n"
            unless $path =~ /^\//;
        $result->{path} = $path;
        $result->{repo} = $entry->{repo} if $entry->{repo};
        $result->{branch} = $entry->{branch} if $entry->{branch};
        push @paths, $result;
    }
    return @paths;
}

sub _deduce_path {
    my ($class, $entry) = @_;
    return $entry->{path} if $entry->{path};
    my $repo = $entry->{repo} || fatal_error "Missing repo?";
    $repo =~ s!.*?([^/]+)?/?$!$1!;
    $repo =~ s/\.git$//;
    $repo
}

# Find all the valid 'dot' files for various operations.
sub _all_files {
    my $class = shift;
    my $get_all = shift || 0;
    my $all_files = {};
    for my $entry ($class->_all_dot_paths) {
        my $path = $entry->{path};
        $class->_check_path($path);
        for my $file (`(cd $path; find -L . -type f)`) {
            $file =~ s!^\./!!;
            chomp($file);
            next unless $file =~ /^(?:\.|tg-bin|bin\/)/;
            next if $file =~ /(\.sw.|~)$/;
            next if $file =~ /\.git\//;
            next if $file =~ /\.(git|gitignore|gitmodules)$/;
            next if $file =~ /^\.\.\.(Makefile|deps)/;
            if (! $all_files->{$file}) {
                $all_files->{$file} = $path;
            }
            elsif ($get_all) {
                my $old = $all_files->{$file};
                $all_files->{$file} = $old = [$old]
                    unless ref($old) eq 'ARRAY';
                push @$old, $path;
            }
        }
    }
    return $all_files;
}

sub _check_path {
    my ($class, $path) = @_;
    if (not -d $path) {
        die <<"...";

'$path' does not exist.

Perhaps you need to run '... update' to get all your repos.

...
    }
}

sub _each_make {
    my ($class, $target) = @_;
    for my $entry ($class->_all_dot_paths) {
        $class->_make($target, $entry->{path});
    }
}

sub _make {
    my ($class, $target, $dots_dir) = @_;
    my $dots_makefile = "$dots_dir/...Makefile";
    return if not -e $dots_makefile;
    $ENV{DOTDOTDOT_ROOT} = $root_dir;
    $class->_run_sys(
        'make', '-C', $dots_dir, '-f', $dots_makefile, $target
    );
}

sub _slurp_file {
    my ($class, $file_name) = @_;
    local $/ = undef;
    local *FH;
    fatal_error("Couldn't read $file_name") unless open(FH, $file_name);
    return <FH>
}

sub _check_deps {
    my $class = shift;
    for my $dphr ($class->_all_dot_paths) {
        my $dots_dir = $dphr->{path};
        my $deps_file_name = "$dots_dir/...deps";
        next unless -f $deps_file_name;
        my $contents = $class->_slurp_file($deps_file_name);
        for my $expected_repo (split /\s+/, $contents) {
            -d "$dots_dir/../$expected_repo"
                or fatal_error "Couldn't find repo: $expected_repo, "
                    . "requested by $deps_file_name";
        }
    }
}

__DATA__
# Inlined and stripped down http://search.cpan.org/~adamk/YAML-Tiny-1.44/
package YAML::Tiny;

use strict;

# UTF Support?
sub HAVE_UTF8 () { $] >= 5.007003 }
BEGIN {
        if ( HAVE_UTF8 ) {
                # The string eval helps hide this from Test::MinimumVersion
                eval "require utf8;";
                die "Failed to load UTF-8 support" if $@;
        }

        # Class structure
        require 5.004;
        require Exporter;
        require Carp;
        $YAML::Tiny::VERSION   = '1.44';
        @YAML::Tiny::ISA       = qw{ Exporter  };
        @YAML::Tiny::EXPORT    = qw{ Load Dump };
        @YAML::Tiny::EXPORT_OK = qw{ LoadFile DumpFile freeze thaw };

        # Error storage
        $YAML::Tiny::errstr    = '';
}

# The character class of all characters we need to escape
# NOTE: Inlined, since it's only used once
# my $RE_ESCAPE = '[\\x00-\\x08\\x0b-\\x0d\\x0e-\\x1f\"\n]';

# Printed form of the unprintable characters in the lowest range
# of ASCII characters, listed by ASCII ordinal position.
my @UNPRINTABLE = qw(
        z    x01  x02  x03  x04  x05  x06  a
        x08  t    n    v    f    r    x0e  x0f
        x10  x11  x12  x13  x14  x15  x16  x17
        x18  x19  x1a  e    x1c  x1d  x1e  x1f
);

# Printable characters for escapes
my %UNESCAPES = (
        z => "\x00", a => "\x07", t    => "\x09",
        n => "\x0a", v => "\x0b", f    => "\x0c",
        r => "\x0d", e => "\x1b", '\\' => '\\',
);

# Special magic boolean words
my %QUOTE = map { $_ => 1 } qw{
        null Null NULL
        y Y yes Yes YES n N no No NO
        true True TRUE false False FALSE
        on On ON off Off OFF
};





#####################################################################
# Implementation

# Create an empty YAML::Tiny object
sub new {
        my $class = shift;
        bless [ @_ ], $class;
}

# Create an object from a file
sub read {
        my $class = ref $_[0] ? ref shift : shift;

        # Check the file
        my $file = shift or return $class->_error( 'You did not specify a file name' );
        return $class->_error( "File '$file' does not exist" )              unless -e $file;
        return $class->_error( "'$file' is a directory, not a file" )       unless -f _;
        return $class->_error( "Insufficient permissions to read '$file'" ) unless -r _;

        # Slurp in the file
        local $/ = undef;
        local *CFG;
        unless ( open(CFG, $file) ) {
                return $class->_error("Failed to open file '$file': $!");
        }
        my $contents = <CFG>;
        unless ( close(CFG) ) {
                return $class->_error("Failed to close file '$file': $!");
        }

        $class->read_string( $contents );
}

# Create an object from a string
sub read_string {
        my $class  = ref $_[0] ? ref shift : shift;
        my $self   = bless [], $class;
        my $string = $_[0];
        unless ( defined $string ) {
                return $self->_error("Did not provide a string to load");
        }

        # Byte order marks
        # NOTE: Keeping this here to educate maintainers
        # my %BOM = (
        #     "\357\273\277" => 'UTF-8',
        #     "\376\377"     => 'UTF-16BE',
        #     "\377\376"     => 'UTF-16LE',
        #     "\377\376\0\0" => 'UTF-32LE'
        #     "\0\0\376\377" => 'UTF-32BE',
        # );
        if ( $string =~ /^(?:\376\377|\377\376|\377\376\0\0|\0\0\376\377)/ ) {
                return $self->_error("Stream has a non UTF-8 BOM");
        } else {
                # Strip UTF-8 bom if found, we'll just ignore it
                $string =~ s/^\357\273\277//;
        }

        # Try to decode as utf8
        utf8::decode($string) if HAVE_UTF8;

        # Check for some special cases
        return $self unless length $string;
        unless ( $string =~ /[\012\015]+\z/ ) {
                return $self->_error("Stream does not end with newline character");
        }

        # Split the file into lines
        my @lines = grep { ! /^\s*(?:\#.*)?\z/ }
                    split /(?:\015{1,2}\012|\015|\012)/, $string;

        # Strip the initial YAML header
        @lines and $lines[0] =~ /^\%YAML[: ][\d\.]+.*\z/ and shift @lines;

        # A nibbling parser
        while ( @lines ) {
                # Do we have a document header?
                if ( $lines[0] =~ /^---\s*(?:(.+)\s*)?\z/ ) {
                        # Handle scalar documents
                        shift @lines;
                        if ( defined $1 and $1 !~ /^(?:\#.+|\%YAML[: ][\d\.]+)\z/ ) {
                                push @$self, $self->_read_scalar( "$1", [ undef ], \@lines );
                                next;
                        }
                }

                if ( ! @lines or $lines[0] =~ /^(?:---|\.\.\.)/ ) {
                        # A naked document
                        push @$self, undef;
                        while ( @lines and $lines[0] !~ /^---/ ) {
                                shift @lines;
                        }

                } elsif ( $lines[0] =~ /^\s*\-/ ) {
                        # An array at the root
                        my $document = [ ];
                        push @$self, $document;
                        $self->_read_array( $document, [ 0 ], \@lines );

                } elsif ( $lines[0] =~ /^(\s*)\S/ ) {
                        # A hash at the root
                        my $document = { };
                        push @$self, $document;
                        $self->_read_hash( $document, [ length($1) ], \@lines );

                } else {
                        Carp::croak("YAML::Tiny failed to classify the line '$lines[0]'");
                }
        }

        $self;
}

# Deparse a scalar string to the actual scalar
sub _read_scalar {
        my ($self, $string, $indent, $lines) = @_;

        # Trim trailing whitespace
        $string =~ s/\s*\z//;

        # Explitic null/undef
        return undef if $string eq '~';

        # Single quote
        if ( $string =~ /^\'(.*?)\'(?:\s+\#.*)?\z/ ) {
                return '' unless defined $1;
                $string = $1;
                $string =~ s/\'\'/\'/g;
                return $string;
        }

        # Double quote.
        # The commented out form is simpler, but overloaded the Perl regex
        # engine due to recursion and backtracking problems on strings
        # larger than 32,000ish characters. Keep it for reference purposes.
        # if ( $string =~ /^\"((?:\\.|[^\"])*)\"\z/ ) {
        if ( $string =~ /^\"([^\\"]*(?:\\.[^\\"]*)*)\"(?:\s+\#.*)?\z/ ) {
                # Reusing the variable is a little ugly,
                # but avoids a new variable and a string copy.
                $string = $1;
                $string =~ s/\\"/"/g;
                $string =~ s/\\([never\\fartz]|x([0-9a-fA-F]{2}))/(length($1)>1)?pack("H2",$2):$UNESCAPES{$1}/gex;
                return $string;
        }

        # Special cases
        if ( $string =~ /^[\'\"!&]/ ) {
                Carp::croak("YAML::Tiny does not support a feature in line '$lines->[0]'");
        }
        return {} if $string =~ /^{}(?:\s+\#.*)?\z/;
        return [] if $string =~ /^\[\](?:\s+\#.*)?\z/;

        # Regular unquoted string
        if ($string !~ /^[>|]/) {
            Carp::croak("YAML::Tiny found illegal characters in plain scalar: '$string'") if
                $string =~ /^(?:-(?:\s|$)|[\@\%\`])/ or
                $string =~ /:(?:\s|$)/;
            $string =~ s/\s+#.*\z//;
            return $string
        }

        # Error
        Carp::croak("YAML::Tiny failed to find multi-line scalar content") unless @$lines;

        # Check the indent depth
        $lines->[0]   =~ /^(\s*)/;
        $indent->[-1] = length("$1");
        if ( defined $indent->[-2] and $indent->[-1] <= $indent->[-2] ) {
                Carp::croak("YAML::Tiny found bad indenting in line '$lines->[0]'");
        }

        # Pull the lines
        my @multiline = ();
        while ( @$lines ) {
                $lines->[0] =~ /^(\s*)/;
                last unless length($1) >= $indent->[-1];
                push @multiline, substr(shift(@$lines), length($1));
        }

        my $j = (substr($string, 0, 1) eq '>') ? ' ' : "\n";
        my $t = (substr($string, 1, 1) eq '-') ? ''  : "\n";
        return join( $j, @multiline ) . $t;
}

# Parse an array
sub _read_array {
        my ($self, $array, $indent, $lines) = @_;

        while ( @$lines ) {
                # Check for a new document
                if ( $lines->[0] =~ /^(?:---|\.\.\.)/ ) {
                        while ( @$lines and $lines->[0] !~ /^---/ ) {
                                shift @$lines;
                        }
                        return 1;
                }

                # Check the indent level
                $lines->[0] =~ /^(\s*)/;
                if ( length($1) < $indent->[-1] ) {
                        return 1;
                } elsif ( length($1) > $indent->[-1] ) {
                        Carp::croak("YAML::Tiny found bad indenting in line '$lines->[0]'");
                }

                if ( $lines->[0] =~ /^(\s*\-\s+)[^\'\"]\S*\s*:(?:\s+|$)/ ) {
                        # Inline nested hash
                        my $indent2 = length("$1");
                        $lines->[0] =~ s/-/ /;
                        push @$array, { };
                        $self->_read_hash( $array->[-1], [ @$indent, $indent2 ], $lines );

                } elsif ( $lines->[0] =~ /^\s*\-(\s*)(.+?)\s*\z/ ) {
                        # Array entry with a value
                        shift @$lines;
                        push @$array, $self->_read_scalar( "$2", [ @$indent, undef ], $lines );

                } elsif ( $lines->[0] =~ /^\s*\-\s*\z/ ) {
                        shift @$lines;
                        unless ( @$lines ) {
                                push @$array, undef;
                                return 1;
                        }
                        if ( $lines->[0] =~ /^(\s*)\-/ ) {
                                my $indent2 = length("$1");
                                if ( $indent->[-1] == $indent2 ) {
                                        # Null array entry
                                        push @$array, undef;
                                } else {
                                        # Naked indenter
                                        push @$array, [ ];
                                        $self->_read_array( $array->[-1], [ @$indent, $indent2 ], $lines );
                                }

                        } elsif ( $lines->[0] =~ /^(\s*)\S/ ) {
                                push @$array, { };
                                $self->_read_hash( $array->[-1], [ @$indent, length("$1") ], $lines );

                        } else {
                                Carp::croak("YAML::Tiny failed to classify line '$lines->[0]'");
                        }

                } elsif ( defined $indent->[-2] and $indent->[-1] == $indent->[-2] ) {
                        # This is probably a structure like the following...
                        # ---
                        # foo:
                        # - list
                        # bar: value
                        #
                        # ... so lets return and let the hash parser handle it
                        return 1;

                } else {
                        Carp::croak("YAML::Tiny failed to classify line '$lines->[0]'");
                }
        }

        return 1;
}

# Parse an array
sub _read_hash {
        my ($self, $hash, $indent, $lines) = @_;

        while ( @$lines ) {
                # Check for a new document
                if ( $lines->[0] =~ /^(?:---|\.\.\.)/ ) {
                        while ( @$lines and $lines->[0] !~ /^---/ ) {
                                shift @$lines;
                        }
                        return 1;
                }

                # Check the indent level
                $lines->[0] =~ /^(\s*)/;
                if ( length($1) < $indent->[-1] ) {
                        return 1;
                } elsif ( length($1) > $indent->[-1] ) {
                        Carp::croak("YAML::Tiny found bad indenting in line '$lines->[0]'");
                }

                # Get the key
                unless ( $lines->[0] =~ s/^\s*([^\'\" ][^\n]*?)\s*:(\s+(?:\#.*)?|$)// ) {
                        if ( $lines->[0] =~ /^\s*[?\'\"]/ ) {
                                Carp::croak("YAML::Tiny does not support a feature in line '$lines->[0]'");
                        }
                        Carp::croak("YAML::Tiny failed to classify line '$lines->[0]'");
                }
                my $key = $1;

                # Do we have a value?
                if ( length $lines->[0] ) {
                        # Yes
                        $hash->{$key} = $self->_read_scalar( shift(@$lines), [ @$indent, undef ], $lines );
                } else {
                        # An indent
                        shift @$lines;
                        unless ( @$lines ) {
                                $hash->{$key} = undef;
                                return 1;
                        }
                        if ( $lines->[0] =~ /^(\s*)-/ ) {
                                $hash->{$key} = [];
                                $self->_read_array( $hash->{$key}, [ @$indent, length($1) ], $lines );
                        } elsif ( $lines->[0] =~ /^(\s*)./ ) {
                                my $indent2 = length("$1");
                                if ( $indent->[-1] >= $indent2 ) {
                                        # Null hash entry
                                        $hash->{$key} = undef;
                                } else {
                                        $hash->{$key} = {};
                                        $self->_read_hash( $hash->{$key}, [ @$indent, length($1) ], $lines );
                                }
                        }
                }
        }

        return 1;
}

# Save an object to a file
sub write {
        my $self = shift;
        my $file = shift or return $self->_error('No file name provided');

        # Write it to the file
        open( CFG, '>' . $file ) or return $self->_error(
                "Failed to open file '$file' for writing: $!"
                );
        print CFG $self->write_string;
        close CFG;

        return 1;
}

# Save an object to a string
sub write_string {
        my $self = shift;
        return '' unless @$self;

        # Iterate over the documents
        my $indent = 0;
        my @lines  = ();
        foreach my $cursor ( @$self ) {
                push @lines, '---';

                # An empty document
                if ( ! defined $cursor ) {
                        # Do nothing

                # A scalar document
                } elsif ( ! ref $cursor ) {
                        $lines[-1] .= ' ' . $self->_write_scalar( $cursor, $indent );

                # A list at the root
                } elsif ( ref $cursor eq 'ARRAY' ) {
                        unless ( @$cursor ) {
                                $lines[-1] .= ' []';
                                next;
                        }
                        push @lines, $self->_write_array( $cursor, $indent, {} );

                # A hash at the root
                } elsif ( ref $cursor eq 'HASH' ) {
                        unless ( %$cursor ) {
                                $lines[-1] .= ' {}';
                                next;
                        }
                        push @lines, $self->_write_hash( $cursor, $indent, {} );

                } else {
                        Carp::croak("Cannot serialize " . ref($cursor));
                }
        }

        join '', map { "$_\n" } @lines;
}

sub _write_scalar {
        my $string = $_[1];
        return '~'  unless defined $string;
        return "''" unless length  $string;
        if ( $string =~ /[\x00-\x08\x0b-\x0d\x0e-\x1f\"\'\n]/ ) {
                $string =~ s/\\/\\\\/g;
                $string =~ s/"/\\"/g;
                $string =~ s/\n/\\n/g;
                $string =~ s/([\x00-\x1f])/\\$UNPRINTABLE[ord($1)]/g;
                return qq|"$string"|;
        }
        if ( $string =~ /(?:^\W|\s)/ or $QUOTE{$string} ) {
                return "'$string'";
        }
        return $string;
}

sub _write_array {
        my ($self, $array, $indent, $seen) = @_;
        if ( $seen->{refaddr($array)}++ ) {
                die "YAML::Tiny does not support circular references";
        }
        my @lines  = ();
        foreach my $el ( @$array ) {
                my $line = ('  ' x $indent) . '-';
                my $type = ref $el;
                if ( ! $type ) {
                        $line .= ' ' . $self->_write_scalar( $el, $indent + 1 );
                        push @lines, $line;

                } elsif ( $type eq 'ARRAY' ) {
                        if ( @$el ) {
                                push @lines, $line;
                                push @lines, $self->_write_array( $el, $indent + 1, $seen );
                        } else {
                                $line .= ' []';
                                push @lines, $line;
                        }

                } elsif ( $type eq 'HASH' ) {
                        if ( keys %$el ) {
                                push @lines, $line;
                                push @lines, $self->_write_hash( $el, $indent + 1, $seen );
                        } else {
                                $line .= ' {}';
                                push @lines, $line;
                        }

                } else {
                        die "YAML::Tiny does not support $type references";
                }
        }

        @lines;
}

sub _write_hash {
        my ($self, $hash, $indent, $seen) = @_;
        if ( $seen->{refaddr($hash)}++ ) {
                die "YAML::Tiny does not support circular references";
        }
        my @lines  = ();
        foreach my $name ( sort keys %$hash ) {
                my $el   = $hash->{$name};
                my $line = ('  ' x $indent) . "$name:";
                my $type = ref $el;
                if ( ! $type ) {
                        $line .= ' ' . $self->_write_scalar( $el, $indent + 1 );
                        push @lines, $line;

                } elsif ( $type eq 'ARRAY' ) {
                        if ( @$el ) {
                                push @lines, $line;
                                push @lines, $self->_write_array( $el, $indent + 1, $seen );
                        } else {
                                $line .= ' []';
                                push @lines, $line;
                        }

                } elsif ( $type eq 'HASH' ) {
                        if ( keys %$el ) {
                                push @lines, $line;
                                push @lines, $self->_write_hash( $el, $indent + 1, $seen );
                        } else {
                                $line .= ' {}';
                                push @lines, $line;
                        }

                } else {
                        die "YAML::Tiny does not support $type references";
                }
        }

        @lines;
}

# Set error
sub _error {
        $YAML::Tiny::errstr = $_[1];
        undef;
}

# Retrieve error
sub errstr {
        $YAML::Tiny::errstr;
}





#####################################################################
# YAML Compatibility

sub Dump {
        YAML::Tiny->new(@_)->write_string;
}

sub Load {
        my $self = YAML::Tiny->read_string(@_);
        unless ( $self ) {
                Carp::croak("Failed to load YAML document from string");
        }
        if ( wantarray ) {
                return @$self;
        } else {
                # To match YAML.pm, return the last document
                return $self->[-1];
        }
}

BEGIN {
        *freeze = *Dump;
        *thaw   = *Load;
}

sub DumpFile {
        my $file = shift;
        YAML::Tiny->new(@_)->write($file);
}

sub LoadFile {
        my $self = YAML::Tiny->read($_[0]);
        unless ( $self ) {
                Carp::croak("Failed to load YAML document from '" . ($_[0] || '') . "'");
        }
        if ( wantarray ) {
                return @$self;
        } else {
                # Return only the last document to match YAML.pm, 
                return $self->[-1];
        }
}





#####################################################################
# Use Scalar::Util if possible, otherwise emulate it

BEGIN {
        eval {
                require Scalar::Util;
                *refaddr = *Scalar::Util::refaddr;
        };
        eval <<'END_PERL' if $@;
# Failed to load Scalar::Util   
sub refaddr {
        my $pkg = ref($_[0]) or return undef;
        if (!!UNIVERSAL::can($_[0], 'can')) {
                bless $_[0], 'Scalar::Util::Fake';
        } else {
                $pkg = undef;
        }
        "$_[0]" =~ /0x(\w+)/;
        my $i = do { local $^W; hex $1 };
        bless $_[0], $pkg if defined $pkg;
        $i;
}
END_PERL

}

1;

$INC{'YAML/Tiny.pm'} = 'inlined';
